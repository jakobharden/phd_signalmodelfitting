## Generate sets of identifiers for atomic data structures#### Usage: [r_ds] = aggr_join(p_as, p_gi, p_li)#### p_t1 ... tag 1, <str>## p_a1 ... array 1, [<uint>] or {<str>}## p_t2 ... tag 2, optional, <str>## p_a2 ... array 2, optional, [<uint>] or {<str>}## p_t3 ... tag 3, optional, <str>## p_a3 ... array 3, optional, [<uint>] or {<str>}## p_t4 ... tag 4, optional, <str>## p_a4 ... array 4, optional, [<uint>] or {<str>}## p_t5 ... tag 5, optional, <str>## p_a5 ... array 5, optional, [<uint>] or {<str>}## r_is ... return: identifier set, {<str>}#### Notes:##   1) always provide pairs of tags and arrays##   2) arrays must not be empty, but may hold a single element only########################################################################################################################### LICENSE####    Copyright (C) 2025 Jakob Harden (jakob.harden@tugraz.at, Graz University of Technology, Graz, Austria)##    This file is part of the PhD thesis of Jakob Harden.####    This program is free software: you can redistribute it and/or modify##    it under the terms of the GNU Affero General Public License as##    published by the Free Software Foundation, either version 3 of the##    License, or (at your option) any later version.####    This program is distributed in the hope that it will be useful,##    but WITHOUT ANY WARRANTY; without even the implied warranty of##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the##    GNU Affero General Public License for more details.####    You should have received a copy of the GNU Affero General Public License##    along with this program.  If not, see <https://www.gnu.org/licenses/>.###########################################################################################################################function [r_is] = aggr_idgen(p_t1, p_a1, p_t2, p_a2, p_t3, p_a3, p_t4, p_a4, p_t5, p_a5)    ## check arguments  if (nargin < 2)    help aggr_idgen;    error('Less arguments given!');  endif  if (nargin < 10) || (nargin < 9)    p_t5 = [];    p_a5 = [];  endif  if (nargin < 8) || (nargin < 7)    p_t4 = [];    p_a4 = [];  endif  if (nargin < 6) || (nargin < 5)    p_t3 = [];    p_a3 = [];  endif  if (nargin < 4) || (nargin < 3)    p_t2 = [];    p_a2 = [];  endif    ## generate group 1  g1 = hlp_itemlist(p_t1, p_a1);  g2 = hlp_itemlist(p_t2, p_a2);  g3 = hlp_itemlist(p_t3, p_a3);  g4 = hlp_itemlist(p_t4, p_a4);  g5 = hlp_itemlist(p_t5, p_a5);    ## generate identifier set  r_is = g1; # group 1  r_is = hlp_addgroup(r_is, g2); # group 2  r_is = hlp_addgroup(r_is, g3); # group 3  r_is = hlp_addgroup(r_is, g4); # group 4  r_is = hlp_addgroup(r_is, g5); # group 5    ## return string if set consists of one item only  if (length(r_is) == 1)    r_is = r_is{1};  endif  endfunctionfunction [r_g] = hlp_itemlist(p_t, p_a)  ## Create items (item = a pair consisting of tag and array item)  ##  ## p_t ... tag, <str>  ## p_a ... array, [<uint>] or {<str>}  ## r_g ... return: items, {<str>}    ## check arguments  if isempty(p_a)    r_g = [];    return;  endif  if isempty(p_t)    r_g = [];    return;  endif    ## convert numeric values to cell string  if isnumeric(p_a)    a = {};    for i = 1 : length(p_a)      a = [a, sprintf('%d', fix(p_a(i)))];    endfor  else    if iscellstr(p_a)      a = p_a;    else      a = {p_a};    endif  endif    ## create items  r_g = {};  for i = 1 : length(a)    r_g = [r_g, sprintf('%s%s', p_t, a{i})];  endfor  endfunctionfunction [r_i] = hlp_addgroup(p_i, p_g)  ## Add group to item list  ##  ## p_i ... item list, {<str>}  ## p_g ... group, {<str>}  ## r_i ... return: item list, {<str>}    if isempty(p_g)    r_i = p_i;    return;  endif    r_i = {};  for i = 1 : length(p_i)    for n = 1 : length(p_g)      r_i = [r_i, sprintf('%s_%s', p_i{i}, p_g{n})];    endfor  endfor  endfunction