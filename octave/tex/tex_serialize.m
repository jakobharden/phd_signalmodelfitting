## Serialize single value of various data types#### FUNCTION SYNOPSIS:#### Usage: [r_vv] = tex_serialize(p_ss, p_vt, p_vv)##                   non-interactive mode#### p_ss ... serialization settings data structure, <struct_tex_settings>## p_vt ... variable type enumerator, <str>## p_vv ... variable value, <any_octave_type>## r_vv ... return: serialized value, <str>#### Note 1)##   Recognized value types are (p_vt):##      string: 'str', 'str_arr', 'str_mat'##      boolean: 'bool', 'bool_arr', 'bool_mat'##      unsigned integer: 'uint', 'uint_arr', 'uint_mat'##      signed integer: 'int', 'int_arr', 'int_mat'##      single precision float: 'float', 'float_arr', 'float_mat'##      double precision float: 'dbl', 'dbl_arr', 'dbl_mat'##      physical units (string): 'unit', 'unitstr'#### Note 2)##   The following LaTeX control sequences are escaped (applies to string values and units).##   String values who's first character is an exclamation mark (!) are not escaped. In that case, only the initial exclamation mark is##   removed from the string. This allows to use the math environment in strings.##     '\' --> '\textbackslash{}'##     '_' --> '\_'##     '#' --> '\#'##     '%' --> '\%'##     '$' --> '\$'##     '~' --> '\ensuremath{\sim}'##     '°' --> '\ensuremath{{}^\circ}'##     '...' --> '\ldots'#### see also: tex_settings.m, sprintf#### Copyright 2023 Jakob Harden (jakob.harden@tugraz.at, Graz University of Technology, Graz, Austria)## License: MIT## This file is part of the PhD thesis of Jakob Harden.## ## Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated ## documentation files (the “Software”), to deal in the Software without restriction, including without ## limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of ## the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:## ## THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ## THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ## AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, ## TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.##function [r_vv] = tex_serialize(p_ss, p_vt, p_vv)    ## check arguments  if (nargin < 3)    help tex_serialize;    error('Less arguments given!');  endif  if isempty(p_vv)    r_vv = '';    return;  endif    ## set default values  if isempty(p_ss)    p_ss = tex_settings();  endif
    ## prepare floating point formats  if (p_ss.ser.fixed_ndig)    ndig_single = sprintf('%d', p_ss.ser.single_ndig);    ndig_double = sprintf('%d', p_ss.ser.double_ndig);    fmt_single = ['%.', ndig_single, 'f'];    fmt_double = ['%.', ndig_double, 'f'];  else    fmt_single = '%f';    fmt_double = '%f';  endif    ## switch value type  switch (p_vt)    case {'str', 'str_arr', 'str_mat', 'unit', 'unitstr'}      ## escape TeX control characters      r_vv = p_vv;      if (r_vv(1) == '!')        ## no character escaping        r_vv = r_vv(2:end);      else        ## escape control characters        r_vv = strrep(r_vv, '\', '\textbackslash{}');        r_vv = strrep(r_vv, '_', '\_');        r_vv = strrep(r_vv, '#', '\#');        r_vv = strrep(r_vv, '%', '\%');        r_vv = strrep(r_vv, '$', '\$');        r_vv = strrep(r_vv, '~', '\ensuremath{\sim}');        r_vv = strrep(r_vv, '°', '\ensuremath{{}^\circ}');        r_vv = strrep(r_vv, '...', '\ldots');      endif
    case {'bool', 'bool_arr', 'bool_mat'}      r_vv = sprintf('%d', p_vv);    case {'uint', 'uint_arr', 'uint_mat'}      r_vv = sprintf('%d', abs(p_vv));    case {'int', 'int_arr', 'int_mat'}      r_vv = sprintf('%d', p_vv);    case {'float', 'float_arr', 'float_mat'}      r_vv = sprintf(fmt_single, p_vv);    case {'dbl', 'dbl_arr', 'dbl_mat'}      r_vv = sprintf(fmt_double, p_vv);    otherwise      r_vv = '';      warning('Unknown value type name: %s', p_vt);  endswitch  endfunction